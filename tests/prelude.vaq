
; global prelude ops and procs

(proc mahproc (x y)
    (* x y 10))

(test proc
    (= 120 (mahproc 3 4)))

(test :
    (= (table 'x 1 'y 2) (: x 1 y 2)))

(test null?
    (null? null))

(test isa?
    (= true (isa? mahproc 'proc)))

(test proc?
    (proc? mahproc))

(test bool?
    (bool? false))

(test symbol?
    (symbol? 'foo))

(test num?
    (and (num? 0) (num? 3.14159)))

(test int?
    (int? 23))

(test text?
    (text? "foo"))

(test pair?
    (and
        (pair? '(1 . 2))
        (pair? (pair 1 2))))

(test list?
    (list? (list 1)))

(test vector?
    (vector? (vector 2 3)))

(test table?
    (table? (: x 1 y 2)))

(test cell
   (= '(7 0 8)
      (let (x (cell 0))
         (def y x.get)
         (x.set! 7)
         x.inc!
         (def z x.get)
         x.dec!
         (list x.get y z))))

(test append
    (= '(1 2 3 4 5) (append '(1 2) '(3) '(4 5))))

(test papply
    (=
        '(partially applied list 1 2 3)
        (let (x (papply list 'partially 'applied 'list))
            (x 1 2 3))))

(test compose
    (let ()
        (proc f (xs) (list-map (_ (* _ _)) xs))
        (proc g (xs) (list-map (_ (+ _ 10)) xs))
        (and
            (= '(121 144 169 196 225 256 289)
                ((compose f g range) 1 7))
            (= '(11 14 19 26 35 46 59)
                ((compose g f range) 1 7)))))

(test cond
    ((thunk
        (proc foo (x)
            (cond
                (= x 0) 'foo
                (= x 1) 'bar
                (= x 2) (+ x x x)
                default: (* x x)))
        (and
            (= 'foo (foo 0))
            (= 'bar (foo 1))
            (= 6    (foo 2))
            (= 9    (foo 3))))))

(test qq
    ((thunk
        (def x 1)
        (def y 'foo)
        (def z (list 2 3))
        (and
            (= (qq x) 'x)
            (= (qq (unq x)) 1)
            (= (qq (unq y)) 'foo)
            (= (qq (unq z)) '(2 3))
            (= (qq (x y z)) '(x y z))
            (= (qq (x (unq x) y (unq y) z (unq z))) '(x 1 y foo z (2 3)))
            (= (qq (x (unq x) y (unq y) z (unqs z))) '(x 1 y foo z 2 3))))))

(test when
    (let ()
        (proc foo (x)
            (when (> x 10) 'is-a-biggun))
        (=  (list (foo 0) (foo 9) (foo 23) (foo 42) (foo 153))
           '(null null is-a-biggun is-a-biggun is-a-biggun))))

;(test chain
;    (let ()
;        (def xs (range 0 10))
;        (proc foo (x) (* x x))
;        (proc bar (x) (and (> x 10) (< x 100)))
;        (= '(81 64 49 36 25 16)
;            (chain xs
;                (map foo)
;                (filter bar)
;                (sort >)))))

(test case
    (let ()
        (proc foo (x)
            (case x
                (0) 'foo
                (1) 'bar
                (2 3) (+ x x x)
                default: (* x x)))
        (and
            (= 'foo (foo 0))
            (= 'bar (foo 1))
            (= 6    (foo 2))
            (= 9    (foo 3))
            (= 16   (foo 4)))))

(test while
    (let (i (cell 0) total (cell 0))
        (def rv
            (while (< i.get 20)
                (total.set! (+ total.get i.get))
                (i.set! i.get.inc)
                (list i.get total.get)))
        (= rv '(20 190))))

(test while-next
    (let (i (cell 0) total (cell 0))
        (def rv
            (while (< i.get 20)
                (i.set! i.get.inc)
                (when (mod i.get 3)
                    (next (list 'next i.get total.get)))
                (total.set! (+ total.get i.get))
                (list i.get total.get)))
        (= rv '(next 20 63))))

(test while-last
    (let (i (cell 0) total (cell 0))
        (def rv
            (while (< i.get 20)
                (i.set! i.get.inc)
                (when (> total.get 30)
                    (last (list 'last i.get total.get)))
                (total.set! (+ total.get i.get))
                (list i.get total.get)))
        (= rv '(last 9 36))))

(test for
    (= 210
        (for (i (cell 0) total (cell 0)) (<= i.get 20) (i.set! i.get.inc)
            (total.set! (+ total.get i.get))
            total.get)))

(test for-next
    (= 110
        (for (i (cell 0) total (cell 0)) (<= i.get 20) (i.set! i.get.inc)
            (when (mod i.get 2)
                (next total))
            (total.set! (+ total.get i.get))
            total.get)))

(test for-redo
    (= 220
        (for (i (cell 0) total (cell 0)) (<= i.get 20) (i.set! i.get.inc)
            (when (mod total.get 2)
                (total.set! total.get.inc)
                (redo total))
            (total.set! (+ total.get i.get))
            total.get)))

(test for-last
    (= 105
        (for (i (cell 0) total (cell 0)) (<= i.get 20) (i.set! i.get.inc)
            (when (> total.get 100)
                (last total.get))
            (total.set! (+ total.get i.get))
            total.get)))

(test each
    (let (items (range 1 5) total (cell 0))
        (each n items
            (total.set! (+ total.get n)))
        (= total.get 15)))

(test each-vector
    (let (items (apply vector (range 1 5) (:)) total (cell 0))
        (each n items
            (total.set! (+ total.get n)))
        (= total.get 15)))

(test each-table
    (let (items (: x 1 y 2 z 3 u 4 v 5) total (cell 0))
        (each n items
            (total.set! (+ total.get n.val)))
        (= total.get 15)))

(test _
    (= '(2 4 9)
        (list
            ((_ (+ _ _)) 1)
            ((_ (* 2 _)) 2)
            ((_ (* _ _)) 3))))

(test resend
    (=
        '(int text symbol real real)
        (let (xs (list 1 "2" 'three 1/4 6.4))
            (list-map (resend 'type) xs))))

(test promise
    (let (count (cell 0))
        (def p
            (promise
                (seq
                    (count.set! count.get.inc)
                    (* 3 4))))
        (and
            (= 'promise p.type)
            (= 12 p.value)
            (= 12 p.value)
            (= 1 count.get))))

(test seal
   (let ()
      (def r (: x 1 y 2))
      (def sr (seal r pass: '(x y)))
      (def hr (seal r hide: '(set! del!)))
      (def xr (seal r pass: '() secret: 'foonballardy)) ; You know nothing about me!
      (proc handler (e k) true)

      (and
         (= sr.type 'sealed-object)
         (and (= sr.x 1) (= sr.y 2))
         (guard
            handler
            (hr.set! 0 2)
            false)
         (guard
            handler
            (xr.get 'x)
            false)
         (seq
            (r.set! 'x 2)
            true)
         (= sr.x 2)
         (= (hr.get 'x) 2)
         (guard
            handler
            (sr.unseal 'wrong)
            false)
         (send (xr.unseal 'foonballardy) 'x))))

(test everywhere
    (= '(50 50)
        (let ()
            (everywhere
                (def x 1)
                (proc sq (x) (* x x)))

            (op foo ()
                %(def bar $(+ x (sq 7))))

            (foo)

            (def baz (+ x (sq 7)))

            (list bar baz))))

(test generic-procedures
    (= '(murakami 4 -4 1 5 16 6 ("1" "2" "3" "4" "5" "6" "7"))
        (let ()
            (gen nosuke 'murakami arity: 7) ; default case
            (spec nosuke (x)
                x.pos?
                (* x x))
            (spec nosuke (x)
                x.neg?
                (- (* x x)))
            (spec nosuke (x y)
                (> x y)
                (+ x y))
            (spec nosuke (x y)
                (< x y)
                (- y x))
            (spec nosuke (x y)
                (= x y)
                (* x y))
            (spec nosuke (x y z)
                rest.size.zero?
                (+ x y z))
            (spec nosuke (x y z p d q r)
                true
                (list-map (_ _.to-text) (list x y z p d q r)))
            (list
                (nosuke 0)
                (nosuke 2)
                (nosuke -2)
                (nosuke 2 3)
                (nosuke 3 2)
                (nosuke 4 4)
                (nosuke 1 2 3)
                (nosuke 1 2 3 4 5 6 7)))))

(test ndx
    ((thunk
        (def roll (ndx 10 6)) ; fireball!
        (and (>= roll 10) (<= roll 60)))))

(test cat
    (and
        (=  "truefalsefoobarbaz"
            (cat true false null 'foo "bar" 'baz))
        (=  "true/false//foo/bar/baz"
            (cat true false null 'foo "bar" 'baz with: "/"))))

(test alias
    (= 100
        (let ()
            (alias lambda fn)
            (def f (fn (x) (* 10 x)))
            (f 10))))

(test any?
    (let (xs '(1 1 1) ys '(1 1 0) zs '(0 0 0))
        (proc is-1 (x) (= x 1))
        (and
            (any? is-1 xs)
            (any? is-1 ys)
            (not (any? is-1 zs)))))

(test every?
    (let (xs '(1 1 1) ys '(1 1 0) zs '(0 0 0))
        (proc is-1 (x) (= x 1))
        (and
            (every? is-1 xs)
            (not (every? is-1 ys))
            (not (every? is-1 zs)))))

(test map
    (let ()
        (def xs '(1 2 3))
        (def ys '(4 5 6))
        (def zs #(vector 7 8 9))
        (proc bam! (x y z)
            (* (+ x y) z))
        (= '(35 56 81)
           (map bam! xs ys zs))))

(test fold
    (let ()
        (def xs '(1 2 3))
        (def ys '(4 5 6))
        (def zs #(vector 7 8 9))
        (proc zap! (x y z acc)
            (+ x y z acc))
        (= 45
           (fold zap! 0 xs ys zs))))

(test zip
    (let ()
        (def xs '(a b c))
        (def ys '(1 2 3))
        (def zs '(x y z))
        (= '((a 1 x) (b 2 y) (c 3 z))
           (zip xs ys zs))))

(test flatten
   (let ()
      (def xs '(1 2 3))
      (def ys '(4 5))
      (def zs (list xs (list (list ys))))
      (= (flatten zs) '(1 2 3 4 5))))

(test bind
   (let ()
      (bind (a b c) '(2 3 5))
      (and (= a 2) (= b 3) (= c 5))))

