
; global environment

(op thunk ()
   (list 'lambda () (pair 'seq rest)))

(proc isa? (thing type)
   (= thing.type type))

(proc bool? (thing)
   (isa? thing 'bool))

(proc lambda? (thing)
   (isa? thing 'lambda))

(proc proc? (thing)
   (or
      (isa? thing 'lambda)
      (isa? thing 'proc)))

(proc op? (thing)
   (isa? thing 'op))

(proc symbol? (thing)
   (isa? thing 'symbol))

(proc stream? (thing)
   (isa? thing 'stream))

(proc socket? (thing)
   (isa? thing 'socket))

(proc null? (thing)
   (is? thing null))

(proc table? (thing)
   (isa? thing 'table))

(proc eof? (x)
   (isa? x 'EOF))

(proc not (x)
   x.to-bool.not)

(proc != (x y)
   (not (= x y)))

(proc >= (x y)
   (not (< x y)))

(proc <= (x y)
   (not (> x y)))

(op and (x)
   (if rest
      (list 'if x (and.apply rest null) 'false)
      (list 'if x 'true 'false)))

(op or (x)
   (def stub (gensym))
   (list 'seq
      (list 'def stub x)
      (list 'if stub stub (if rest (or.apply rest null) 'false))))

(proc and? (x)
   (if x
      (if rest
         (and?.apply rest null)
         true)
      false))

(proc or? (x)
   (if x
      x
      (if rest
         (or?.apply rest null)
         false)))

(proc nand ()
   (not (and?.apply rest null)))

(proc nor ()
   (not (or?.apply rest null)))

(proc xor (x y)
   (nor (and? x y) (nor x y)))

(proc identity (x) x)

(proc append (xs ys)
   (def rv (xs.append ys))
   (if rest
      (append.apply (pair rv rest) null)
      rv))

(proc apply (f args options)
   (f.apply args options))

(proc papply (f)
   ((lambda (cargs)
      (proc ()
         (f.apply (append cargs rest) opt))) rest))

(proc error (name form message)
   (fail
      (object 'type 'error
              'name name
              'form form
              'view (list 'error name form message)
              'message message
              'to-text message)))

(proc compose ()
   ((proc (funz)
      (def s funz.size)
      (if (= s 0)
         (error 'too-few-args %(compose @rest) "(compose ...) requires at least one argument.  It prefers more than one.")
         (if (= s 1)
            rest.head
            (if (= s 2)
               (proc () (funz.head (apply funz.tail.head rest opt)))
               (compose funz.head (apply compose funz.tail null)))))) rest))

(op loop (name vars)
   (proc sep (x y xs names vals)
      (if xs.empty?
         (pair (send (pair x names) 'reverse) (send (pair y vals) 'reverse))
         (sep xs.head xs.1 xs.tail.tail (pair x names) (pair y vals))))
   (def p
      (if vars.empty?
         (pair () ())
         (sep vars.head vars.1 vars.tail.tail () ())))
   (def lambda-form
      ((send (list 'lambda p.head) 'append)
         (list
            (pair 'seq rest))))
   (def args (gensym))
   (list
      'let
      (list args (pair 'list p.tail))
      (list 'def name lambda-form)
      (list (list 'send name ''apply) args 'null)))

(op : () ; table op
   (pair 'table
      (if (pair? rest)
         (if (= (mod rest.size 2) 0)
            (loop go (k rest.head v rest.1 xs rest.tail.tail acc ())
               (def noob (pair (list 'quote k) (pair v acc)))
               (if (pair? xs)
                  (go xs.head xs.tail.head xs.tail.tail noob)
                  noob))
            (error 'args-fail %(: @rest) "(: ...) requires an even number of arguments"))
            ())))

(op cond ()
   (def default
      (if (opt.get 'default)
         (opt.get 'default)
         (list 'error ''cond-no-matching-clause (list 'pair ''cond (list 'quote rest)) "(cond... ) form fell through!")))
   (if (< rest.size 2)
      (error 'syntax-error (pair 'cond rest) "(cond ...) should have at least one predicate and consequent.")
      (loop go (pred rest.0 conseq rest.1 remaining rest.tail.tail)
         (if remaining
            (list 'if pred conseq (go remaining.0 remaining.1 remaining.tail.tail))
            (list 'if pred conseq default)))))

(op qq (expr)
   (proc constant? (expr)
      (if (pair? expr)
         (= expr.head 'quote)
         (send (= 'symbol expr.type) 'not)))
   (proc combine-skeletons (left right expr)
      (cond
         (and (constant? left) (constant? right))
            (if (and (= (env.eval left)  expr.head)
                     (= (env.eval right) expr.tail))
               (list 'quote expr)
               (list 'quote (pair (env.eval left) (env.eval right))))
         (= right ())
            (list 'list left)
         (and (pair? right) (= right.head 'list))
            (pair 'list (pair left right.tail))
         default: (list 'pair left right)))
   (proc expand-quasiquote (expr nesting)
      (cond
         (send (pair? expr) 'not)
            (if (constant? expr)
               expr
               (list 'quote expr))
         (and (is? expr.head 'unq) (= expr.size 2))
            (if nesting.zero?
               expr.1
               (combine-skeletons
                  ''unq
                  (expand-quasiquote expr.tail nesting.dec)
                  expr))
         (and (is? expr.head 'qq) (= expr.size 2))
            (combine-skeletons
               ''qq
               (expand-quasiquote expr.tail nesting.inc)
               expr)
         (and (pair? expr.head) (= expr.head.head 'unqs) (= expr.head.size 2))
            (if (= nesting 0)
               (list (list 'send expr.head.1 ''append)
                    (expand-quasiquote expr.tail nesting))
               (combine-skeletons
                  (expand-quasiquote expr.head nesting.dec)
                  (expand-quasiquote expr.tail nesting)
                  expr))
         default:
            (combine-skeletons
               (expand-quasiquote expr.head nesting)
               (expand-quasiquote expr.tail nesting)
               expr)))
   (expand-quasiquote expr 0))

(op when (pred)
   (qq
      (if (unq pred)
         (seq (unqs rest))
         null)))

(op case (val)
   (def default
      (if (opt.get 'default)
         (opt.get 'default)
         (list 'error ''case-no-matching-clause (list 'pair ''case (list 'quote rest)) "(case ...) form fell through!")))
   (if (< rest.size 2)
      (error 'syntax-error (pair 'case rest) "(case ...) should have at least one predicate and consequent.")
      (seq
         (def cval (gensym))
         (qq
            (let ((unq cval) (unq val))
               (unq
                  (loop go (set rest.0 conseq rest.1 remaining rest.tail.tail)
                     (def pred (qq ((send (quote (unq set)) 'has?) (unq cval))))
                     (if remaining
                        (list 'if pred conseq (go remaining.0 remaining.1 remaining.tail.tail))
                        (list 'if pred conseq default)))))))))

(op while (pred body)
   ; call (next <value>) to skip the rest of the bodies and go to the next loop (continue)
   ;     if predicate evals false, <value> will be returned from the while expression
   ; call (last <value>) to terminate the loop and return said value (break)
   (def jump (gensym))
   (def rv (gensym))
   (def kont (gensym))
   %(gate
      ((thunk
         (def $jump
            (lambda ($rv)
               (seq
                  (proc next (v) (capture $kont ($jump v)))
                  (proc last (v) (capture $kont v))
                  (if $pred
                     ($jump (seq @(pair body rest)))
                     $rv))))
         ($jump null)))))

(op everywhere ()
   %(seq @rest (compile-eval @rest)))

(everywhere
   (proc list-fold (f acc xs)
      (if xs.empty?
         acc
         (list-fold f (f xs.head acc) xs.tail)))

   (proc list-reduce (f acc xs)
      (if xs.empty?
         acc
         (f xs.head (list-reduce f acc xs.tail))))

   (proc list-map (f xs)
      (if xs
         (pair (f xs.head) (list-map f xs.tail))
         ()))

   (proc list-filter (f xs)
      (list-reduce (lambda (x y) (if (f x) (pair x y) y)) '() xs))

   (def list-sort
      (let ()
         (def merge (lambda (f a b)
            (if a.size.zero?
               b
               (if b.size.zero?
                  a
                  (if (f a.head b.head)
                     (pair a.0 (merge f a.tail b))
                     (pair b.0 (merge f a b.tail)))))))

         (def sort (lambda (f yarr)
            (def len yarr.size)
            (if (< len 2)
               yarr
               (seq
                  (def half (send (/ len 2) 'floor))
                  (merge f (sort f (yarr.take half)) (sort f (yarr.drop half)))))))

         (lambda (f xs)
            (sort f xs)))))


(op _ (body)
   (def uscore (gensym))
   (def bodies (pair body rest))
   (proc rename (form)
      (if (pair? form)
         (if (= form.head '_)
            form
            (list-map rename form))
         (if (= form '_)
            uscore
            form)))
   (qq
      (lambda ((unq uscore))
         (seq (unqs (rename bodies))))))

(op ensure (thnk)
   (def v (gensym))
   %(guard
      (proc (e k)
         ($thnk)
         (fail e))
      (gate
         (let ($v (seq @rest))
            ($thnk)
            $v))))

(op test (name expr)
   %(let (ok $expr)
      (if ok
         (say (list (quote $name) 'ok))
         (log (list (quote $name) 'FAIL)))))

(proc cell (value)
   (def box (vector value))
   (object
      'type 'cell
      'view (lambda () (list box.0))
      'get  (lambda () box.0)
      'set! (lambda (v)
               (seq
                  (box.set! 0 v)
                  v))
      'inc! (lambda () (box.set! 0 (+ box.0 1)))
      'dec! (lambda () (box.set! 0 (- box.0 1)))
      auto: '(get view inc! dec!)))

(op qw ()
   (pair 'list (list-map (lambda (x) x.to-text) rest)))

(op with-gensyms (gs)
   (def pairs (list-map (_ (list _ '(gensym))) gs))
   (def lets
      (loop go (x pairs.head xs pairs.tail)
         (if xs
            (go (x.append xs.head) xs.tail)
            x)))
   %(let $lets @rest))

(op chain (obj)
   (loop go (init obj cmd rest.head cmds rest.tail)
      (def form %((send $init (quote $(send cmd 'head))) @(send cmd 'tail)))
      (if cmds
         (go form cmds.head cmds.tail)
         form)))

(op for (init pred update body)
   (def bodies (pair body rest))
   (with-gensyms (jump rv tmp kont)
      %(gate
         (let $init
            (def $jump
               (lambda ($rv)
                  (seq
                      (proc redo (v) (last ($jump v)))
                      (proc next (v) (seq $update (redo v)))
                      (proc last (v) (capture $kont v))
                      (if $pred
                         (let ($tmp (seq @bodies))
                            $update
                            ($jump $tmp))
                         $rv))))
            ($jump null)))))

(op each (name arg body)
   (def bodies (pair body rest))
   (with-gensyms (xs jump)
     %(let ($xs (send $arg 'to-list))
         (proc $jump ($name)
            @bodies)
         (list-map $jump $xs))))

(proc range (start end)
   (def step (if opt.step opt.step 1))
   (loop go (i start acc ())
      (if (> i end)
         acc.reverse
         (go (+ i step) (pair i acc)))))

(op matrix ()
   ; (matrix ((0 0 1) (0 0 2)) ((0 1 1) (0 2 1)))
   ;     -> (vector: (vector: (vector: 0 0 1) (vector: 0 0 2)) (vector: (vector: 0 1 1) (vector: 0 2 1)))
   (qq
      (vector
         (unqs
            (list-map
               (_ (if (pair? _)
                    (qq (matrix (unqs _)))
                   _)
               rest))))))

(op gen (name body)
   (def opt-arity (if opt.arity opt.arity 5))
   (qq
      (def (unq name)
         (let (default (cell (proc () (unqs (pair body rest))))
               clauses (vector.apply (list-map (_ ()) (range 0 $opt-arity)) (:)))
            (proc add-clause! (pred body)
               (def idx pred.arity)
               (clauses.set!
                  idx
                  (pair (pair pred body) (clauses idx))))
            (proc set-default! (body)
               (default.set! body))
            (proc gen-apply (args options)
               (def arity args.size)
               (loop go (n arity)
                  (def cs (clauses n))
                  (proc n-zero ()
                     (if n.zero?
                        (default.get.apply args options)
                        (go n.dec)))
                  (if (not (pair? cs))
                     (n-zero)
                     (loop jump (x cs.head xs cs.tail)
                        (if (x.head.apply args options)
                           (x.tail.apply args options)
                           (if (pair? xs)
                              (jump xs.head xs.tail)
                              (n-zero)))))))
            (proc view ()
               (send
                  (pair clauses (pair 'default default.get))
                  'view))
            (object
               'add-clause! add-clause!
               'set-default! set-default!
               'apply gen-apply
               'view view
               'arity $opt-arity
               (unq 'auto:) '(view)))))) ; not sure why (unq (quote keyword:)) works, but I'll take it

(op spec (name args pred body)
   (qq ((send (unq name) 'add-clause!)
          (proc (unq args) (unq pred))
          (proc (unq args) (unqs (pair body rest))))))

(op assert (predicate)
   (with-gensyms (testy result)
      (qq
         (let ((unq testy) (quote (unq predicate)) (unq result) (unq predicate))
            (if (unq result)
               true
               (error 'assertion-failed (unq testy) "(assert ...) FAIL"))))))

(proc ndx (n x)
   (when (or (< n 0) (< x 0))
      (error 'type-error %(ndx $n $x) "usage: (ndx n x) : n and x must be integers greater than zero."))
   (proc dx ()
      (+ 1 (rand x)))
   (loop go (m n total 0)
      (if m.zero?
         total
         (go m.dec (+ total (dx))))))

(proc repl (e in out err)
   (out.print "vaquero> ")
   (def input in.read)
   (when (isa? input 'EOF)
      (return "End Of Line."))
   (def result (e.eval input))
   (out.say result)
   (repl e in out err))

(proc parse (s)
   s.to-stream.read-seq)

(proc resend (msg)
   (lambda (obj) (send obj msg)))

(def json
   (let ()
      (def syms '(true false null))

      (proc json-in (txt)
         #(doc this parser is pretty good at accepting valid JSON.
               It is less good at rejecting invalid JSON.  Rough draft.)
         (proc read-num (p)
            p.read.to-number)
         (proc read-text (p)
            p.read)
         (proc read-symbol (p)
            p.read.to-symbol)
         (proc read-array (p)
            p.read-char ; discard opening [
            (loop go (next p.peek-char items ())
               (when (eof? next)
                  (error 'json-read-error items "Unexpected EOF in JSON array!"))
               (if next.whitespace?
                   (seq p.read-char (go p.peek-char items))
                   (case next
                      ("]")     (seq p.read-char items.reverse)
                      (",")     (seq p.read-char (go p.peek-char items))
                      default:
                         (let (item (reader p))
                             (go p.peek-char (items.cons item)))))))
         (proc read-object (p)
            p.read-char ; discard opening {
            (loop go (next p.peek-char items (table))
               (when (eof? next)
                  (error 'json-read-error items "Unexpected EOF in JSON object!"))
               (if next.whitespace?
                  (seq p.read-char (go p.peek-char items))
                  (case next
                     ("}")  (seq p.read-char items)
                     (",")  (seq p.read-char (go p.peek-char items))
                     default:
                        (let (key (send (reader p) 'to-symbol))
                           (p.skip-while " :\t\n")
                           (let (val (reader p))
                              (items.set! key val)
                              (go p.peek-char items)))))))
         (proc reader (p)
            (def next p.peek-char)
            (when (eof? next)
               (return next))
            (if next.whitespace?
               (seq
                  p.read-char
                  (reader p))
               (case next
                  ("\"")    (read-text p)
                  ("[")     (read-array p)
                  ("]")     (error 'json-read-error txt "Unexpected ] !")
                  ("{")     (read-object p)
                  ("}")     (error 'json-read-error txt "Unexpected } !")
                  ("-" "0" "1" "2" "3" "4" "5" "6" "7" "8" "9")
                      (read-num p)
                  default:
                     (let (this-guy (read-symbol p))
                        (if (not (syms.has? this-guy))
                           (error 'json-read-error this-guy "Unquoted string!")
                           this-guy)))))
         (reader txt.to-stream))

         (proc json-out (thing)
            (proc comma-fy (xs)
               (cat.apply xs (: with ",")))
            (cond
               (null? thing)   thing.to-text
               (bool? thing)   thing.to-text
               (num? thing)    thing.to-text
               (symbol? thing) (json-out thing.to-text)
               (text? thing)   (cat "\"" (thing.replace "\"" "\\\"" flags: "g") "\"")
               (vector? thing) (json-out thing.to-list)
               (table? thing) (cat "{" (comma-fy (list-map (lambda (kv) (cat (json-out kv.key.to-text) ":" (json-out kv.val))) thing.to-list)) "}")
               (list? thing)   (cat "[" (comma-fy (list-map json-out thing)) "]")
               (pair? thing)   (cat "[" (json-out thing.head) "," (json-out thing.tail) "]")
               default:
                  (if (thing.responds? 'to-json)
                     thing.to-json
                     (error 'json-write-error thing "json.write - unknown-type"))))

         (object
            'read json-in
            'write json-out
            'parse json-in
            'stringify json-out)))

(op promise (expr) ; lazy evaluation
   (def result (gensym))
   %(let ($result (cell null))
      (object
         auto: '(value)
         'type 'promise
         'view '(promise $expr)
         'value (lambda ()
                   (if (is? (send $result (quote get)) null)
                      (seq
                         ((send $result (quote set!)) $expr)
                         (send $result (quote get)))
                      (send $result (quote get)))))))

(proc seal (obj)
   (def passed  (or opt.pass ()))
   (def hidden  (or opt.hide ()))
   (def secret  (or opt.secret null))
   (def type    'sealed-object)

   (proc none-shall-pass (m)
       (not (hidden.has? m)))

   (def forward
      (if passed
         passed
         (if hidden
            (list-filter none-shall-pass obj.messages)
            ())))

   (proc unseal (xyzzy)
      (if (null? secret)
         (error 'ACCESS-DENIED sealed "ACCESS DENIED")
         (if (= xyzzy secret)
            obj
            (error 'ACCESS-DENIED sealed "ACCESS DENIED"))))

   (def sealed
      (object
         'type type
         'unseal unseal
         forward: %(($obj @forward))))

   sealed)

(op alias (name new-alias)
   %(op $new-alias ()
      %($'$name @rest)))

(proc any? (f xs)
   (when (not (proc? f))
      (error 'bad-argument %(any? $f $xs @rest)
                           "any?: first argument must be a procedure."))
   (def ys xs.to-list)
   (loop go (z ys.head zs ys.tail)
      (if (f z)
         true
         (if (pair? zs)
            (go zs.head zs.tail)
            false))))

(proc every? (f xs)
   (when (not (proc? f))
      (error 'bad-argument %(every? $f $xs @rest) "every?: first argument must be a procedure."))
   (def ys xs.to-list)
   (loop go (z ys.head zs ys.tail)
      (if (f z)
         (if (pair? zs)
            (go zs.head zs.tail)
            true)
         false)))

(proc map (f xs) ; general map
   (when (not (proc? f))
      (error 'bad-argument %(map $f $xs @rest) "map: first argument must be a procedure."))
   (proc get-heads (xs)
      (list-map (resend 'head) xs))
   (proc get-tails (xs)
      (list-map (resend 'tail) xs))
   (let (objz (pair xs rest))
      (def lists (list-map (resend 'to-list) objz))
      (loop go (heads (get-heads lists) tails (get-tails lists) results ())
         (def noo (pair (apply f heads null) results))
         (if (every? identity tails)
            (go (get-heads tails) (get-tails tails) noo)
            noo.reverse))))

(proc fold (kons knil) ; general fold
   (when (not (proc? kons))
      (error 'bad-argument %(fold $kons $knil @rest) "fold: first argument must be a procedure."))
   (def lists (list-map (resend 'to-list) rest))
   (proc fold-m (kons knil lists)
      (if (any? (resend 'empty?) lists)
         knil
         (fold-m kons
            (apply kons (append (list-map (resend 'head) lists) (list knil)) null)
            (list-map (resend 'tail) lists))))
   (fold-m kons knil lists))

(proc zip (xs)
   (apply map %($list $xs @rest) null))

(proc flatten (xs)
   (cond
      (= xs ()) ()
      (not (pair? xs)) (list xs)
      default: (append (flatten xs.head)
                       (flatten xs.tail))))

(op bind (names)
   ; FIXME expand to destructure trees as well as lists
   (def expr-val (gensym))
   (proc define (name n)
      %(def $name (send $expr-val $n)))
   (def defz (map define names (range 0 names.size.dec)))
   %(seq
      (def $expr-val (seq @rest))
      @defz))

(op github (name sym)
   (def txt sym.to-text)
   (def xs (txt.split "/"))
   (def user xs.0)
   (def repo xs.1)
   (def module-path
      (cat (cat.apply (xs.drop 2) (: with "/")) ".vaq"))
   (def uri (cat "https://raw.githubusercontent.com" user repo "master" module-path with: "/"))
   %(use $name $uri))

; reserving for future use

(def ! null)
(def ? null)
(def & null)
(def ~ null)
(def ^ null)

(def global env)

