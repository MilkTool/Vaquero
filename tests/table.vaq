
; tables

(def barerec (table))
(def simp (table 'x 2 'y 3))
(def rec-one (: foo 23))

(def deep-1 (: x 2 y (: foo 3 bar (: baz 5))))
(def deep-2 (: x 2 y (: foo 3 bar (: baz 5))))

(test table-type (= simp.type '(table)))
(test table-true (= true simp.to-bool))
(test table-false (= false barerec.to-bool))

(test table-equality (= deep-1 deep-2))

(test message-send (and (= simp.x 2) (= simp.y 3)))
(test table-apply (= 2 (simp 'x)))

; primitive messages

(test table-has? (simp.has? 'x))
(test table-get (= 2 (simp.get 'x)))
(test table-put (= 5 (send (simp.put 'z 5) 'z)))

(test table-set!
    (= 7
        (seq
            (simp.set! 'z 7)
            simp.z)))

(test table-rm
    (seq
        (def noob (simp.rm 'z 5))
        (and (simp.has? 'z) (not (noob.has? 'z)))))

(test table-del!
    (= false
        (seq
            (simp.del! 'z)
            (simp.has? 'z))))

(test table-size (= simp.size 2))

(test table-keys (= '(x y) (list-sort < simp.keys))) 

(test table-values
    (= '(2 3)
        (list-sort < simp.values)))

(test table-pairs
    (= (list '(x . 2) '(y . 3))
       (list-sort (lambda (a b) (< a.tail b.tail)) simp.pairs)))

(test table-to-list
    (= (list '(x . 2) '(y . 3))
       (list-sort (lambda (a b) (< a.tail b.tail)) simp.to-list)))

(test table-to-set
   (= (set '(x . 2) '(y . 3))
      simp.to-set))

(test table-to-table
   (= (: x 2 y 3)
      simp.to-table))

;(test table-merge ; table equality is broken...
;    (seq
;        (def r1 (: x 1 y 2))
;        (def r2 (: y 5 z 8))
;        (and
;            (= (r1.merge r2) (: x 1 y 5 z 8))  
;            (= (r2.merge r1) (: x 1 y 2 z 8)))))

;(def yor (: a 1 b 2 c 3 d 4 e 5))

;(test table-fold
;    (= 15
;       (yor.fold 0 (lambda (total kv) (+ total kv.val)))))

;(test table-reduce
;    (= '(total . 120)
;       (yor.reduce
;            '(total . 1)
;            (lambda (total kv) (pair 'total (* total.val kv.val))))))

;(test table-map
;    (let ()
;        (proc square-pair (p)
;            (pair p.key (* p.val p.val)))
;        (def noob (yor.map square-pair))
;        (= '(1 4 9 16 25) (list-sort < noob.values))))

;(test table-filter
;    (let ()
;        (proc kill4 (p)
;            (!= p.val 4))
;        (def noob (yor.filter kill4))
;        (= '(1 2 3 5) (list-sort < noob.values))))

